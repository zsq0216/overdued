# PJ2 DOCUMENT
## 如何使用我的应用程序
### 界面介绍
* ![alt](1.1.png)
1. 起点终点设置，各有23个地点供选择。注意，**路表示的是一个地点，而不是整条路。
2. 初始地图，标记了各点位置及名称。该地图来源于高德地图。
3. 路线图例，在生成路径后地图上会显示路径和每段路径的权值。
4. 选择出行方式。
5. 显示推荐路径。
### 操作演示
#### 上海人民广场 到 南京东路 （步行）
* ![alt](1.2.png)
* 从图中可见清晰的路径输出，包括出发点、途径点、终点，两点之间的通行方式和时间，以及总时间。
* 由于UI界面制作水平有限，地图上显示的路径是所有步行方式可连通的路径，而并非所求的路径。

#### 上海人民广场 到 东方明珠 （地铁优先）
* ![alt](1.3.png)
* 选择地铁路径偏好。由于并非每个点都设有地铁站，所以该模式下推荐的路径可能是步行和地铁结合的。
* 由于UI界面制作水平有限，地图上显示的路径是所有地铁方式可连通的路径以及只能步行的路径，而并非所求的路径。
* 点击“清空”按钮即可把地图恢复到没有路径标记的初始模式。

## 算法实现
### 我要步行
* 使用的是`Dijkstra`最短路径算法的`优先队列`优化版。原因如下：
  * 该地图不存在权值为负的边，在这种情况下dijkstra算法不会出错
  * 基于最小堆的优先队列可以使每次找到最短边的效率降到log(n)

### 地铁优先
* 先用dijkstra算法找到`出发点距离每个地铁站的最短路径`，若终点也是地铁站点，那么至此已完成路线规划。
* 若终点不是地铁站，还需要用dijkstra算法找到`终点距离每个地铁站的最短路径`，然后用类似Floyd算法的加点思想遍历每个地铁站点，比较res[地铁站v] +backres[地铁站v]和res[终点],更新res[终点]为值小的那个。
* >res存的是从起点出发到其他点的用时，backres是从终点出发到其他店的用时。

### 其他设计细节
* 用枚举类型定义点集。这样可以方便我在写代码时直接使用地点的名字，将名字对应到编号的事交给编译器完成。
* 用邻接矩阵储存边。因为该地图是一个小范围的图，点与点之间的联系较为稠密，不会造成太大的空间浪费。并且用邻接矩阵能使代码更易读。
* 设置了一个isMetro的标识，用于辨别某点是否为地铁站。
* 边结构重载了>运算符，方便在存入优先队列后快速根据权值大小选出最小值。
* 用pre[]数组存储最短路径中每个节点的前一站
* 最后的路径显示（包括时间统计）是以带换行符的字符串形式输出的。因此我还写了一个把整型转为字符串型的函数intTOstr(int a)，把时间以字符串的形式显示。

## 时间复杂度分析
* 假设地图是已初始化的，这里不把初始化地图的时间算入最短路径算法中。
* 设点数为V，边数为E，平均每个点的边数E/V
* 分析优先队列在最坏情况下的性能：
  * 获取堆顶元素T EXTRACT = O(1)
  * 删除堆顶元素T DELETE = O (log(n))
  * 插入  T INSERT = O (log(n))
* 时间复杂度
  * =(V − 1) ∗ (T EXTRACT + T DELETE + T INSERT∗E/V)
  * =(V − 1) ∗ (1 + log(V) + log(V)*E/V)
  * =V ∗ (1 + E/V) * logV
  * =( V + E ) * logV
* "地铁优先"模式比"我要步行"模式多一步遍历地铁站顶点的操作，该操作的时间复杂度为O(V)。因此“地铁优先”时间复杂度也是( V + E ) * logV
